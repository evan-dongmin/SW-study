# 2장 - 서버 성능 개선 기초
- 1장에서는 성능개선을 위해서 알아보아야 할 지표들에 대해서 알아보았다.
- 병목지점이 어디서 발생하는지 알아보았고, 이제 성능개선을 위한 기초 방법론들은 2장에서 알아볼 것이다.

## 수직 확장과 수평 확장
- 서버 성능을 개선하기 위한 가장 쉽고 빠른 방법은 수직 확장이다.
- 가령 사용하던 PC가 느리면 최신 버전의 PC(더 높은 스펙의 하드웨어)로 교체하는 것과 같다.
- 그러나 수직 확장은 근본적인 문제는 아미녀 급한 불을 끄는 방법에 지나지 않는다.
- 수직확장은 특히 클라우드 환경에서는 비용이 급격히 증가하는 단점이 있다. 가성비가 좋지 않다.
- 트래픽이 지속적으로 증가하면 또 다시 성능 문제가 발생한다. 그렇다고 수직 확장을 무한정 할 수는 없다.
- 수직 확장 다음으로 고려해야 할 방법은 수평 확장이다. 사용자의 요청을 받아 줄 수 있는 PC 대수를 늘리는 방법이다.
- 결국엔 TPS가 높아지긴 하지만 이 또한 근본적인 해결책이 아니다. 실제 병목지점이 어딘지 파악하는게 중요하다.
- 1장에서 대부분의 병목지점이 외부 API 연동과 DB연동에서 발생한다고 하였다.
- 그렇다고 DB를 사용하는 서버를 더 늘리는건 DB에 가해지는 부하가 더 커지고 성능은 더 악화될 수 있다.
  - DB를 수평확장하게 된다는건 노드가 많아진다는 뜻이고 이는 노드끼리 경쟁이 붙는다는 것이다.(ACID 특)
  - 그리고 DB는 수평확장보다 수직확장에 더 적합하다.

## DB 커넥션 풀
- DB를 사용하려면 다음의 3단계를 거친다
  - 1.DB에 연결한다.
  - 2.쿼리를 실행한다.
  - 3.사용이 끝나면 연결을 종료한다.
- 네트워크에서 DB를 연결하고 종료하는 시간은 전체 응답시간에 영향을 준다.
- 이러한 영향을 줄이기 위해 DB 커넥션 풀을 사용한다.
  - DB 커넥션 풀은 DB의 연결된 커넥션을 미리 생성해서 보관하는 것이다.
  - 애플리케이션은 DB 작업이 필요할 때 풀에서 커넥션을 가져와 사용하고, 작업이 끝나면 다시 풀에 반환한다.
- 그리고 커넥션 풀 운영에 필요한 다양한 설정을 할 수 있다.
  - 커넥션 풀 크기(또는 최소,최대 크기)
  - 풀이 커넥션이 없을때 커넥션을 구할 때까지 대기할 시간
  - 커넥션의 유지 시간(최대 유휴 시간,최대 유지 시간
- 커넥션 풀은 요청상황에 따라서 최소 크기, 최대 크기를 가질 수 있다.
  - 최소 크기는 애플리케이션이 시작될 때 미리 생성되는 커넥션의 수이다.
  - 최대 크기는 트래픽이 증가할 때 커넥션 풀이 가질 수 있는 최대 커넥션의 수이다.
- 커넥션 풀 크기를 늘리면 처리량을 높힐 수 있다.
  - 그러나 무턱대고 높이면 DB에 부하를 줄 수 있다.

## 커넥션 대기시간
- 커넥션을 얻기 위해 기다릴 수 있는 최대 시간을 의미한다.
- 커넥션을 구하지 못하면 DB 연결 실패 에러가 발생한다.
- 응답시간이 중요한 서비스는 커넥션 대기 시간을 가능한 짧게 설정하는 것이 좋다.
- 사용자가 기다리는 것보다 빠르게 실패를 알려주는 것이 사용자 경험 측면에서도, 안정적인 서버 운영 측면에서도 더 낫기 때문이다.

## 최대 유휴 시간, 유효성 검사,최대 유지시간
- MySQL과 같은 DB는 클라이언트와 일정 시간동안 상호작용이 없으면 자동으로 연결을 끊는다.
- 이때 서버에서 끊어진 커넥션을 커넥션 풀에서 재사용하려고 하면 에러가 발생한다.
- 이를 방지하기 위해 커넥션 풀은 다음 2가지 기능을 제공한다.
  - 최대 유휴 시간 지정
  - 유효성 검사 지원
- 최대 유휴 시간은 사용되지 않는 커넥션을 풀에 유지할 수 있는 최대 시간을 의미한다.
- 유효성 검사는 커넥션이 정상적으로 사용할 수 있는 상태인지 여부를 확인하는 절차이다. -> 연결이 유효하지 않은 커넥션을 식별하고 풀에서 제거할 수 있다.
- 최대 유지 시간은 커넥션이 생성된 시점부터 풀에 유지될 수 있는 최대 시간을 의미한다.

## 서버 캐시
- 모든 데이터를 항상 DB에 저장하고 꺼낸다 하면 DB에 부하가 많이 걸린다. 그리고 응답시간도 늘어난다.
- 응답 시간을 줄이고 처리량을 높히기 위해서는 DB 서버를 확장하는 방법도 있지만, 캐시 사용을 고려하면 요청에 대해 비용과 응답시간을 줄일 수 있다.
- 자주 조회되는 데이터가 있는지 확인하고, 있다면 캐시에 저장하는 방법을 사용한다.
- 캐시는 일종의 (키,값) 쌍을 저장하는 일종의 Map과 같은 형태의 데이터 저장소 이다.
- 캐시를 효율적으로 사용하고 있는지를 확인할 수 있는 지표러 는 캐시 적중률(hit rate)이 있다.
    - 적중률(hit rate) = (캐시에 존재한 건수 / 캐시 조회 수) * 100
- 캐시에 데이터를 100번 조회했는데 그중 87번은 해당 데이터가 존재했다고 가정하면 적중률은 87%가 된다.
  - 적중률이 높을 수록 DB부하가 줄고 응답시간 감소,처리량 증가로 이어진다.
  - 적중률을 높히는 방법은 최대한 캐시에 많은 데이터를 저장하는 것이다.
  - 그러나 캐시를 저장하는 메모리는 한정되어있다. 메모리가 부족하면 어플리케이션 성능이 급격히 저하될 수 있다.
  - 따라서 캐시에서 오래된 데이터를 제거하는 정책이 필요하다.
    - LRU(Least Recently Used) : 가장 오랫동안 사용되지 않은 데이터를 제거
    - LFU(Least Frequently Used) : 가장 적게 사용된 데이터를 제거
    - TTL(Time To Live) : 데이터가 캐시에 저장된 후 일정 시간이 지나면 제거
  - 위 정책을 적절히 조합해서 사용해야 메모리를 효율적으로 활용할 수 있다.

## 로컬 캐시와 리모트 캐시
- 캐시는 로컬 캐시와 리모트 캐시로 나눌 수 있다.
- 로컬 캐시는 서버 프로세스와 동일한 메모리를 캐시 저장소로 사용한다. 인메모리 캐시라고 불린다.
  - 대표적인 로컬 캐시 솔루션으로는 Caffeine(자바), go-cache(Go), node-cache(노드JS) 등이 있다.
  - 장점으로는 서버 프로세스와 같은 메모리를 사용하기 때문에 데이터 접근 속도가 매우 빠르다. 그리고 구조가 단순하다.
  - 단점으로는 데이터 크기에 제한이 있다는 점이다. 서버 프로세스가 사용할 수 있는 메모리양은 한정되어 있기 때문이다.
    - 예를들어 톰캣이 구동이 될때 사용할 수 있는 최대 메모리가 2GB로 설정되어 있다면, 로컬 캐시가 사용할 수 있는 메모리도 2GB를 넘을 수 없다.
    - (더 쓰려면 톰캣의 설정을 바꿔야 한다. -> 서버를 재시작해야함)
    - 그리고 휘발성이기 때문에 서버가 재시작되면 캐시 데이터가 모두 사라진다.
- 리모트 캐시는 별도의 프로세스를 캐시 저장소로 사용한다.
  - 대표적인 리모트 캐시 솔루션으로는 Redis, Memcached가 있다. (Redis를 인 메모리 저장소로 불리지만 리모트 캐시이다.)
  - 장점으로는 캐시 크기를 유연하게 확장할 수 있다는 것이다.
    - 레디스의 경우 여러 대의 레디스 서버를 이용해서 수평 확장할 수 있는 기능을 제공해준다. 캐싱할 데이터 규모가 큰 경우 유리하다.
  - 단점으로는 속도가 로컬캐시보다 느리다는 것이다.
    - 서버 프로세스는 외부 캐시서버와 통신을 주고받아야 한다.
    - 리모트 캐시를 운영하려면 별도의 서버 장비또는 프로세스가 필요하다. -> 시스템 구조가 복잡해진다.
  - 캐시에 보관할 데이터 규모가 작거나 변경 빈도가 매우 낮다면 로컬 캐시로 충분하다.
  - 반면 데이터 규모가 크다면 리모트 캐시를 사용해야 한다.
    - 트래픽이 많은 대형 쇼핑몰 사이트의 개별 정보가 이에 해당한다. (대량의 상품 정보를 캐시에 저장해야 하는 경우)
    - 배포 빈도가 높은 서비스라면 적극 고려하자.

## 캐시 사전적재
- 캐시에 미리 데이터를 저장해야 트래픽이 순간적으로 몰려도 안정적으로 대응할 수 있다.
  - 예를들어 300만명의 사용자 중 푸시 알림을 받고 앱에 접속하는 사용자가 50%라고 가정해보자.
  - 이 경우 150만명의 사용자가 동시에 접속할 수 있다.
  - 이때 캐시에 미리 데이터를 저장해두지 않으면 DB에 엄청난 부하가 걸릴 수 있다.
  - 미리 캐시에 데이터를 저장해두면 DB부하를 줄이고 안정적으로 대응할 수 있다.
## 캐시 무효화
- 캐시에 저장된 데이터가 변경되었을 때 이를 반영하는 작업을 캐시 무효화라고 한다.
  - 금전 거래와 같은 데이터가 자주 바뀌는 경우 그에 맞춰서 캐시에 저장된 데이터를 갱신해야 한다.
  - 변경에 민감한 데이터는 로컬 캐시가 아닌 리모트 캐시에 보관하도록 하자.

## 가비지 컬렉터와 메모리 사용
- 앞선 내용은 대부분 DB와 API응답에 대한 성능 개선 방법론이었다.
- 가비지 컬렉터가 응답 시간에 영향을 주는 경우도 있다. 자바에서 가비지 컬렉터가 실행되는 동안 애플리케이션의 실행이 중단 된다.
- 메모리가 많이 사용되고 생성된 객체가 많을 수록 사용하지 않은 객체를 찾는데 더 많은 시간이 걸린다.
- 앱에서 사용하는 메모리 사용을 줄이면 GC 실행 시간을 단축할 수 있다. 그러나 메모리 사용량을 무턱대고 줄이면 메모리 부족 현상이 발생할 수 있다.
- 실제 메모리 사용 패턴에 맞게 힙 크기를 조정하는 것이 중요하다.
- 한번에 대량으로 객체를 생성하는 것도 주의해야 한다. 게시글 하나가 0.5km의 메모리를 사용한다면 10만개의 게시글은 대략 50MB의 메모리를 사용한다.
- 동시에 100명의 사용자가 요청을 한다면 5GB의 메모리가 필요하다.
- 위 경우의 해결책 중 하나는 조회 범위를 제한하는 것이다.
- 파일 다운로드와 같은 기능을 구현할 때는 스트림을 활용해야 한다.
- 파일 데이터를 한꺼번에 메모리에 로딩한 후에 응답하는 방식은 피해야 한다.

## 응답 데이터 압축
- 응답 시간에는 데이터 전송 시간이 포함된다.
  - 네트워크 속도
  - 전송 데이터 크기
- 서버는 사용자의 네트워크 속도를 제어할 수 없지만 전송하는 데이터의 크기는 제어할 수 있다.
- gzip으로 압축하면 70% 이상 크기를 줄일 수 있다. 데이터 크기가 줄어든 만큼 전송 시간도 단축된다.

## 정적 자원과 브라우저 캐시
- 서버는 동적자원,정적자원 이렇게 2가지 종류의 데이터를 응답한다.
- 정적 자원같은 경우에 HTTP 프로토콜에서는 데이터를 응답할때 Cache-Control 헤더를 통해서 브라우저 캐시를 제어할 수 있다.
- `Cache-Control: max-age=60` 
  - 위 헤더는 브라우저에게 해당 자원을 1시간(60초)동안 캐시에 저장하도록 지시한다.
- 브라우저 캐시를 활용해서 서버 입장에서도 전송해야 할 트래픽이 줄어들어 그만큼 네트워크 전송 비용을 아낄 수 있다.


## 정적 자원과 CDN
- 정적 자원을 CDN(Content Delivery Network)을 통해서 제공하는 방법도 있다.
- 콘텐츠를 제공하기 위한 별도의 서버 네트워크를 의미한다.
- CDN서버는 지리적으로 분산되어 있어서 사용자와 가까운 서버에서 콘텐츠를 제공할 수 있다.
- 때문에 CDN 서버를 사용하면 오리진 서버가 처리해야 할 트래픽을 상당히 줄일 수 있다.

## 대기처리
- 짧은 시간동안 폭증하는 트래픽은 어떻게 처리해야 할까?
- 서버를 미리 증설할 수 도 있지만 DB부하가 심해지면 소용이 없다.
- 수평,수직 확장을 생각할 수도 있지만 짧은 시간을 버티기 위해 투입해야 하는 비용이 크다.
- 이럴때는 대기처리(queueing)를 고려할 수 있다.
- 수용할 수 있는 수준의 트래픽만 받아들이고 나머지는 대기처리 하는 방법이다. 
  - 이렇게 하면 사용자의 지속적인 새로고침으로 인한 트래픽 폭증도 방지할 수 있다. 새로고침으로 사용자의 순번이 뒤로 밀리기 때문에 불필요한 새로고침을 자제하게 된다.
- 높은 부하로 인해 서비스 자체가 아예 안되는 것 보다 대기하는 편이 낫다.